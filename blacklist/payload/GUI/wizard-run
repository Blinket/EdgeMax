#!/usr/bin/env perl

use v5.14;
use lib q(/opt/vyatta/share/perl5/);
use lib q{/config/lib/perl/};
use EdgeOS::DNS::Blacklist (qw{ get_cfg_actv });
use JSON::PP qw(decode_json encode_json);

use constant TRUE  => 1;
use constant FALSE => 0;

my $version = 1.1;
my $action  = $ARGV[0];
my $file    = $ARGV[1];
my $name    = q(dnsmasq blacklist);
my $begin   = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper begin};
my $commit  = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper commit};
my $delete  = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper delete};
my $end     = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper end};
my $save    = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper save};
my $set     = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper set};

sub apply {
  my $base_node = q{service dns forwarding blacklist};
  my $cfg       = {};
  my @cfg_cmds  = ( $begin . q{;} );

  $cfg = decode_json( &get_file( { file => $file } ) );

  if ( keys %{$cfg} ) {
    $cfg->{disabled} = $cfg->{disabled} == 0 ? q{false} : q{true};
    push @cfg_cmds, qq{$set $base_node disabled $cfg->{disabled};};
    push @cfg_cmds,
      qq{$set $base_node dns_redirect_ip } . qq{$cfg->{dns_redirect_ip};};

    for my $exclude ( keys %{ $cfg->{exclude} } ) {
      push @cfg_cmds, qq{$set $base_node exclude $exclude;};
    }

    for my $area (qw{domains hosts zones}) {
      push @cfg_cmds, qq{$set $base_node $area dns_redirect_ip }
        . qq{$cfg->{$area}->{dns_redirect_ip};};

      for my $include ( keys %{ $cfg->{$area}->{include} } ) {
        push @cfg_cmds, qq{$set $base_node $area include $include;};
      }

      for my $exclude ( keys %{ $cfg->{$area}->{exclude} } ) {
        push @cfg_cmds, qq{$set $base_node $area exclude $exclude;};
      }

      for my $source ( keys %{ $cfg->{$area}->{src} } ) {
        push @cfg_cmds, qq{$set $base_node $area source $source description }
          . qq{'$cfg->{$area}->{src}->{$source}->{description}';};
        push @cfg_cmds, qq{$set $base_node $area source $source prefix }
          . qq{'$cfg->{$area}->{src}->{$source}->{prefix}';};
        push @cfg_cmds, qq{$set $base_node $area source $source url }
          . qq{'$cfg->{$area}->{src}->{$source}->{url}';};
      }
    }
    push @cfg_cmds, $commit . q{;};
    push @cfg_cmds, $save . q{;};
    push @cfg_cmds, $end . q{;};
  }
  else {
    print encode_json( { success => 0, error => qq($name not installed!), } );
    return;
  }

# Save filehandles for STDOUT and STDERR
  open( STDOUT_ORIG, q(>&STDOUT) );
  open( STDERR_ORIG, q(>&STDERR) );

# Set new filehandles for STDOUT and STDERR
  my $temp = qq(/tmp/error.$$);
  open( STDOUT, q(>), $temp ) or die qq($0: cannot open STDOUT: $!);
  open( STDERR, q(>&STDOUT) ) or die qq($0: cannot open STDERR: $!);
  print(qq(### Errors reported by $0 version $version ###\n));

  my $output = system(qq{@cfg_cmds});
  my $err    = $?;

  close(STDOUT);
  close(STDERR);
  open( STDOUT, q(>&STDOUT_ORIG) );
  open( STDERR, q(>&STDERR_ORIG) );

  if ( !$err ) {
    print encode_json( { success => 1, } );
  }
  else {
    print encode_json( { success => 0, error => qx(cat $temp), } );
  }
  close(STDOUT_ORIG);
  close(STDERR_ORIG);
  unlink($temp);
}

# Read a file into memory and return the data to the calling function
sub get_file {
  my $input = shift;
  my @data  = ();
  if ( -f $input->{file} ) {
    open my $CF, q{<}, $input->{file}
      or die qq{error: Unable to open $input->{file}: $!};
    chomp( @data = <$CF> );
    close $CF;
  }
  return @data;
}

sub load {
  my $cfg = { success => 1, data => {}, tmp => {}, };
  my $blacklist = get_cfg_actv( { config => $cfg->{tmp}, show => 0 } );

  if ($blacklist) {
    $cfg->{tmp}->{disabled}
      = $cfg->{tmp}->{disabled} == 0 ? qq{false} : qq{true};

    $cfg->{tmp}->{global} = {
      dns_redirect_ip => $cfg->{tmp}->{dns_redirect_ip},
      disabled        => $cfg->{tmp}->{disabled},
    };

    $cfg->{tmp}->{global}->{excludes}
      = [ map { { exclude => $_ } } sort keys %{ $cfg->{tmp}->{exclude} } ]
      if exists $cfg->{tmp}->{exclude};

    $cfg->{data}->{global} = [ $cfg->{tmp}->{global} ];

    # Add areas to process only if they contain sources
    my @areas;
    for my $area (qw{domains hosts zones}) {
      push @areas, $area if scalar keys %{ $cfg->{tmp}->{$area}->{src} };
    }

    # Rename root keys, so that the Feature Wizard gets unique field names
    for my $area (@areas) {

      my @includes
        = map { { include => $_ } }
        sort keys %{ $cfg->{tmp}->{$area}->{blklst} }
        if exists $cfg->{tmp}->{$area}->{blklst};

      my @excludes
        = map { { exclude => $_ } }
        sort keys %{ $cfg->{tmp}->{$area}->{exclude} }
        if exists $cfg->{tmp}->{$area}->{exclude};

      my @sources = map {
        my $key = $_;
        { source => [ %{ $cfg->{tmp}->{$area}->{src}->{$key} } ] }
        } sort keys %{ $cfg->{tmp}->{$area}->{src} }
        if exists $cfg->{tmp}->{$area}->{src};

      $cfg->{data}->{$area} = {
        dns_redirect_ip => $cfg->{tmp}->{dns_redirect_ip},
        includes        => \@includes,
        excludes        => \@excludes,
        sources         => \@sources,
      };
    }
    delete $cfg->{tmp};
    print encode_json($cfg);
  }
  else {
    print encode_json( { success => 0, error => qq($name not installed!), } );
    return;
  }
}

sub remove {

# Save filehandles for STDOUT and STDERR
  open( STDOUT_ORIG, q(>&STDOUT) );
  open( STDERR_ORIG, q(&STDERR) );

# Set new filehandles for STDOUT and STDERR
  my $temp = qq(/tmp/error.$$);
  open( STDOUT, q(>), $temp ) or die qq($0: cannot open STDOUT: $!);
  open( STDERR, q(>&STDOUT) ) or die qq($0: cannot open STDERR: $!);
  print(qq(### Errors reported by $0 version $version ###\n));

  my $cfg_lvl .= q(service dns forwarding blacklist);
  my $remove_blacklist
    = join( q{;}, $begin, qq{$delete $cfg_lvl}, $commit, $save, $end );
  my $output = system($remove_blacklist);
  my $err    = $?;

  close(STDOUT);
  close(STDERR);
  open( STDOUT, q{>&STDOUT_ORIG} );
  open( STDERR, q{>&STDERR_ORIG} );

  if ( !$err ) {
    print encode_json( { success => 1, } );
  }
  else {
    print encode_json( { success => 0, error => qx(cat $temp), } );
  }

  close(STDOUT_ORIG);
  close(STDERR_ORIG);
  unlink($temp);
}

given ($action) {
  when (/apply/)  { apply; }
  when (/delete/) { remove; }
  when (/load/)   { load; }
  default         { die qq{Unknown action: $!}; }
}

