#!/usr/bin/env perl

use v5.14;
use lib q(/opt/vyatta/share/perl5/);
use EdgeOS::DNS::Blacklist (qw{ get_cfg_actv });
use JSON::PP qw(decode_json encode_json);

use constant TRUE  => 1;
use constant FALSE => 0;

my $version = 1.1;
my $action  = $ARGV[0];
my $file    = $ARGV[1];
my $name    = q(dnsmasq blacklist);
my $begin   = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper begin};
my $commit  = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper commit};
my $delete  = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper delete};
my $end     = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper end};
my $save    = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper save};
my $set     = q{/opt/vyatta/sbin/vyatta-cfg-cmd-wrapper set};

sub apply {
  my $base_node = q{service dns forwarding blacklist};
  my $cfg       = {};
  my @cfg_cmds  = ( $begin . q{;} );

  $cfg = decode_json( &get_file( { file => $file } ) );

  if ( keys %{ $cfg->{data} } ) {
    $cfg->{data}->{disabled}
      = $cfg->{data}->{disabled} == 0 ? q{false} : q{true};
    push @cfg_cmds, qq{$set $base_node disabled $cfg->{data}->{disabled};};
    push @cfg_cmds, qq{$set $base_node dns_redirect_ip }
      . qq{$cfg->{data}->{dns_redirect_ip};};

    for my $exclude ( keys %{ $cfg->{data}->{exclude} } ) {
      push @cfg_cmds, qq{$set $base_node exclude $exclude;};
    }

    for my $area (qw{domains hosts zones}) {
      push @cfg_cmds, qq{$set $base_node $area dns_redirect_ip }
        . qq{$cfg->{data}->{$area}->{dns_redirect_ip};};

      for my $include ( keys %{ $cfg->{data}->{$area}->{include} } ) {
        push @cfg_cmds, qq{$set $base_node $area include $include;};
      }

      for my $exclude ( keys %{ $cfg->{data}->{$area}->{exclude} } ) {
        push @cfg_cmds, qq{$set $base_node $area exclude $exclude;};
      }

      for my $source ( keys %{ $cfg->{data}->{$area}->{src} } ) {
        push @cfg_cmds, qq{$set $base_node $area source $source description }
          . qq{'$cfg->{data}->{$area}->{src}->{$source}->{description}';};
        push @cfg_cmds, qq{$set $base_node $area source $source prefix }
          . qq{'$cfg->{data}->{$area}->{src}->{$source}->{prefix}';};
        push @cfg_cmds, qq{$set $base_node $area source $source url }
          . qq{'$cfg->{data}->{$area}->{src}->{$source}->{url}';};
      }
    }
    push @cfg_cmds, $commit. q{;};
    push @cfg_cmds, $save . q{;};
    push @cfg_cmds, $end . q{;}
  }
  else {
    print encode_json( { success => 0, error => qq($name not installed!), } );
    return;
  }

# Save filehandles for STDOUT and STDERR
  open( STDOUT_ORIG, q(>&STDOUT) );
  open( STDERR_ORIG, q(>&STDERR) );

# Set new filehandles for STDOUT and STDERR
  my $temp = qq(/tmp/error.$$);
  open( STDOUT, q(>), $temp ) or die qq($0: cannot open STDOUT: $!);
  open( STDERR, q(>&STDOUT) ) or die qq($0: cannot open STDERR: $!);
  print(qq(### Errors reported by $0 version $version ###\n));

  my $output = system(qq{@cfg_cmds});
  my $err = $?;

  close(STDOUT);
  close(STDERR);
  open( STDOUT, q(>&STDOUT_ORIG) );
  open( STDERR, q(>&STDERR_ORIG) );

  if ( !$err ) {
    print encode_json( { success => 1, } );
  }
  else {
    print encode_json( { success => 0, error => qx(cat $temp), } );
  }
  close(STDOUT_ORIG);
  close(STDERR_ORIG);
  unlink($temp);
}

# Read a file into memory and return the data to the calling function
sub get_file {
  my $input = shift;
  my @data  = ();
  if ( -f $input->{file} ) {
    open my $CF, q{<}, $input->{file}
      or die qq{error: Unable to open $input->{file}: $!};
    chomp( @data = <$CF> );
    close $CF;
  }
  return @data;
}

sub load {
  my $cfg = { success => 1, data => {}, };
  my $blacklist = get_cfg_actv( { config => $cfg->{data}, show => 0 } );

  if ( keys %{ $cfg->{data} } ) {
    $cfg->{data}->{disabled}
      = $cfg->{data}->{disabled} == 0 ? q{false} : q{true};

#     for my $exclude ( keys %{ $cfg->{data}->{exclude} } ) {
#     }

    my $area (qw{domains hosts zones}) {
      while (my ($key, $value) = each %{ $cfg->{data}->{$area}->{include} } ) {
        $cfg->{data}->{qq{$area_include}}->{$key} = $value;
        delete $cfg->{data}->{$area}->{include}->{$key};
      }

      while (my ($key, $value) = each %{ $cfg->{data}->{$area}->{exclude} } ) {
        $cfg->{data}->{qq{$area_exclude}}->{$key} = $value;
        delete $cfg->{data}->{$area}->{exclude}->{$key};
      }

      while (my ($key, $value) = each %{ $cfg->{data}->{$area}->{src} } ) {
        $cfg->{data}->{qq{$area_src}}->{$key} = $value;
        delete $cfg->{data}->{$area}->{src}->{$key};
      }
    }
    print encode_json($cfg);
  }
  else {
    print encode_json( { success => 0, error => qq($name not installed!), } );
    return;
  }
}

sub remove {

# Save filehandles for STDOUT and STDERR
  open( STDOUT_ORIG, q(>&STDOUT) );
  open( STDERR_ORIG, q(&STDERR) );

# Set new filehandles for STDOUT and STDERR
  my $temp = qq(/tmp/error.$$);
  open( STDOUT, q(>), $temp ) or die qq($0: cannot open STDOUT: $!);
  open( STDERR, q(>&STDOUT) ) or die qq($0: cannot open STDERR: $!);
  print(qq(### Errors reported by $0 version $version ###\n));

  my $cfg_lvl .= q(service dns forwarding blacklist);
  my $remove_blacklist
    = join( q{;}, $begin, qq{$delete $cfg_lvl}, $commit, $save, $end );
  my $output = system($remove_blacklist);
  my $err    = $?;

  close(STDOUT);
  close(STDERR);
  open( STDOUT, q{>&STDOUT_ORIG} );
  open( STDERR, q{>&STDERR_ORIG} );

  if ( !$err ) {
    print encode_json( { success => 1, } );
  }
  else {
    print encode_json( { success => 0, error => qx(cat $temp), } );
  }

  close(STDOUT_ORIG);
  close(STDERR_ORIG);
  unlink($temp);
}

given ($action) {
  when (/apply/)  { apply; }
  when (/delete/) { remove; }
  when (/load/)   { load; }
  default         { die qq{Unknown action: $!}; }
}

